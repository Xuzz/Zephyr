
#import "BaseGesture.h"
#import "OffscreenGesture.h"
#import "Preferences.h"
#import "Keyboard.h"
#import "Grabber.h"

static NSMutableArray *allGestures = nil;

%ctor {
    // XXX: memory leak?
    allGestures = [[NSMutableArray alloc] init];
}

@implementation ZephyrBaseGesture
@synthesize isActive, gestureRecognizers;

+ (BOOL)isAnyGestureActive {
    BOOL isActive = NO;

    for (ZephyrBaseGesture *gesture in allGestures) {
        if ([gesture isActive]) {
            isActive = YES;
        }
    }

    return isActive;
}

- (id)init {
    if ((self = [super init])) {
        gestureRecognizers = [[NSMutableArray alloc] init];
        [allGestures addObject:self];
    }

    return self;
}

- (void)cancelGesture {
    isActive = NO;
}

- (void)addOffscreenEdge:(SBOffscreenEdge)edge minimumTouchCount:(int)touchCount edgeMargin:(CGFloat)sensitivity {
    SBOffscreenSwipeGestureRecognizer *gestureRecognizer = [[objc_getClass("SBOffscreenSwipeGestureRecognizer") alloc] initForOffscreenEdge:edge];
    [gestureRecognizer setAllowableDistanceFromEdgeCenter:CGFLOAT_MAX];
    [gestureRecognizer setSendsTouchesCancelledToApplication:YES];
    [gestureRecognizer setRequiresSecondTouchInRange:NO];
    [gestureRecognizer setMinTouches:touchCount];
    [gestureRecognizer setEdgeMargin:sensitivity];
    // [gestureRecognizer setFalseEdge:-1.0f]; // what is this?
    [gestureRecognizer setTypes:0x10];

    [gestureRecognizer setHandler:^{
        CGFloat distance = [gestureRecognizer cumulativePercentage];
        CGPoint velocity = [gestureRecognizer movementVelocityInPointsPerSecond];

        switch ([gestureRecognizer state]) {
            case 0:
                break;
            case 1:
                if (![self isActive] && ![ZephyrBaseGesture isAnyGestureActive]) {
                    if (![self shouldUseGrabberAtEdge:edge] || [[ZephyrGrabberController sharedInstance] visibleAtEdge:edge]) {
                        [[ZephyrGrabberController sharedInstance] hideAtEdge:edge animated:YES];

                        [self handleGestureBegan:gestureRecognizer withLocation:distance];
                        isActive = YES;
                    } else {
                        [[ZephyrGrabberController sharedInstance] showAtEdge:edge animated:YES];
                    }
                }
                break;
            case 2:
                if ([self isActive]) {
                    [self handleGestureChanged:gestureRecognizer withLocation:distance velocity:velocity];
                }
                break;
            case 3:
                if ([self isActive]) {
                    [self handleGestureEnded:gestureRecognizer withLocation:distance velocity:velocity completionType:[gestureRecognizer completionTypeProjectingMomentumForInterval:5.0f]];
                    isActive = NO;
                }
                break;
            case 4:
                // XXX: this is disabled because it is called even if the gesture was never actually "started":
                // there is no way (currently) to tell if a gesture was started before it got cancelled, so this
                // gives us spurious cancelations that break any gesture with two possible recognizers. :(
                // XXX: the above text is not true. if both gestures are enabled then the active gesture is somehow
                // automatically canceled. I do not know why this is, but it requires us to sadly ignore cancels now.
                // [self handleGestureCanceled:gestureRecognizer];
                // isActive = NO;
                break;
            default:
                if ([self isActive]) {
                    NSLog(@"[Zephyr] BUG: Weird recognizer state %d in %@.", [gestureRecognizer state], self);
                    isActive = NO;
                }
                break;
        }
    }];

    [gestureRecognizer setCanBeginCondition:^BOOL {
        BOOL should = [self shouldActivateAtEdge:edge];
        if (!should) return NO;

		return YES;
    }];

    [gestureRecognizers addObject:gestureRecognizer];
    SBGestureRecognizerRegister(gestureRecognizer);
}

- (void)dealloc {
    for (SBGestureRecognizer *gestureRecognizer in gestureRecognizers) {
        [gestureRecognizers removeObject:gestureRecognizer];
        SBGestureRecognizerUnregister(gestureRecognizer);

        [gestureRecognizer release];
    }

    [super dealloc];
}

- (BOOL)currentOrientationIsSupported {
    // Use -activeInterfaceOrientation to get around the faked orientation as reported by CurrentInterfaceOrientation() on the iPhone.
    //return [[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad || [SBApp activeInterfaceOrientation] == UIInterfaceOrientationPortrait;
    return YES;
}

- (BOOL)shouldUseGrabberAtEdge:(SBOffscreenEdge)edge {
    return NO;
}

- (BOOL)shouldActivateAtEdge:(SBOffscreenEdge)edge {
    return NO;
}

- (void)handleGestureBegan:(SBGestureRecognizer *)recognizer withLocation:(CGFloat)location {

}

- (void)handleGestureChanged:(SBGestureRecognizer *)recognizer withLocation:(CGFloat)location velocity:(CGPoint)velocity {

}

- (void)handleGestureEnded:(SBGestureRecognizer *)recognizer withLocation:(CGFloat)location velocity:(CGPoint)velocity completionType:(int)type {

}

- (void)handleGestureCanceled:(SBGestureRecognizer *)recognizer {

}

@end

%group DisableHardwareButtons
%hook SpringBoard

- (void)lockButtonDown:(GSEventRef)event {
    if ([ZephyrBaseGesture isAnyGestureActive]) return;

    %orig;
}

- (void)lockButtonUp:(GSEventRef)event {
    if ([ZephyrBaseGesture isAnyGestureActive]) return;

    %orig;
}

- (void)menuButtonDown:(GSEventRef)event {
    if ([ZephyrBaseGesture isAnyGestureActive]) return;

    %orig;
}

- (void)menuButtonUp:(GSEventRef)event {
    if ([ZephyrBaseGesture isAnyGestureActive]) return;

    %orig;
}

- (void)_handleMenuButtonEvent {
    if ([ZephyrBaseGesture isAnyGestureActive]) return;

    %orig;
}

%end
%end

%ctor {
    %init(DisableHardwareButtons);
}


