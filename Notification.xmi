#import "Common.h"
#import "Notification.h"
#import "Preferences.h"
#import "Keyboard.h"
#import "NSTimer+Blocks.h"

#import "SwitchApp.h"

#include <dlfcn.h>

@implementation NotificationGesture

- (BOOL)shouldActivate {
    // This is needed to prevent re-activation before the animation completes, crashing.
    BOOL switchAppGestureIsAnimating = SwitchAppGestureIsAnimatingCompletion();

    return ![SBApp _accessibilityIsSystemGestureActive]
        && ![[objc_getClass("SBAwayController") sharedAwayController] isLocked]
        && ![[objc_getClass("SBUIController") sharedInstance] isSwitcherShowing]
        && ![[objc_getClass("SBAssistantController") sharedInstance] isAssistantVisible]
        /*&& ![[objc_getClass("SBBulletinWindowController") sharedInstance] isBusy]
        && ![[objc_getClass("SBBulletinListController") sharedInstanceIfExists] listViewIsActive]*/
        && !switchAppGestureIsAnimating
        && [self currentOrientationIsSupported];
}

- (void)handleGestureCanceled {
}

- (void)handleGestureBeganWithLocation:(CGFloat)location {
}

- (void)handleGestureChangedWithLocation:(CGFloat)location velocity:(CGPoint)velocity {
}

- (void)handleGestureEndedWithLocation:(CGFloat)location velocity:(CGPoint)velocity completionType:(int)type {
}

@end

%group Notification

@interface SBBulletinListController (Zephyr)
- (void)cleanupViews;
- (void)prepareAtLocation:(CGFloat)location;
@end

%hook SBBulletinListController

static UIView *appView = nil;
static UIView *wrapperView = nil;
static SBBulletinListView *centerView = nil;
static UIImageView *shadowView = nil;
static CGFloat grabLocation = NAN;

%new(v@:)
- (void)cleanupViews {
    SBApplication *app = [SBApp _accessibilityFrontMostApplication];

    if (app != nil) {
        [[[objc_getClass("SBUIController") sharedInstance] rootView] setAlpha:0.0f];
        [app disableContextHostingForRequester:(CFStringRef) @"SwitchApp"];
    }

    [appView release];
    [appView removeFromSuperview];
    appView = nil;

    centerView = nil;

    [shadowView release];
    [shadowView removeFromSuperview];
    shadowView = nil;

    [wrapperView release];
    [wrapperView removeFromSuperview];
    wrapperView = nil;
}

- (void)_cleanupAfterShowListView {
    %orig;
    grabLocation = NAN;

    [self cleanupViews];
}

- (void)_cleanupAfterHideListView {
    %orig;
    grabLocation = NAN;

    [self cleanupViews];
}

- (void)prepareToShowListViewAnimated:(BOOL)showListViewAnimated aboveBanner:(BOOL)banner {
    %orig;

    [self prepareAtLocation:0.0f];
}

- (void)prepareToHideListViewAnimated:(BOOL)animated {
    %orig;

    if (!isnan(grabLocation)) {
        [self prepareAtLocation:grabLocation];
    } else {
        [self prepareAtLocation:ZephyrHeightForOrientation(ZephyrCurrentInterfaceOrientation())];
    }
}

%new(v@:f)
- (void)prepareAtLocation:(CGFloat)location {
    [self cleanupViews];
    grabLocation = location;

    SBApplication *app = [SBApp _accessibilityFrontMostApplication];

    if (app != nil) {
        [[[objc_getClass("SBUIController") sharedInstance] rootView] setAlpha:1.0f];

        UIView *gestureView = [[objc_getClass("SBGestureViewVendor") sharedInstance] viewForApp:app gestureType:kSBGestureTypeSwitchApp includeStatusBar:YES];

        CGRect gestureFrame = [gestureView frame];
        gestureFrame.origin = CGPointZero;

        appView = [[UIView alloc] initWithFrame:gestureFrame];
        [appView addSubview:gestureView];
    } else {
        // XXX: using contentView here isn't necessarily the best option, but it works.
        appView = ZephyrViewWithScreenshotOfView([[objc_getClass("SBUIController") sharedInstance] contentView]);
        [appView retain];

        // Call private UIKit API to cancel touches on the icon lists while swiping.
        // This fixes the bug where swiping up on an icon would start editing mode.
        if ([SBApp respondsToSelector:@selector(_cancelAllTouches)])
            [SBApp performSelector:@selector(_cancelAllTouches)];
    }

    if (ZephyrCurrentInterfaceOrientation() != ZephyrHomeInterfaceOrientation()) {
        ZephyrRotateViewFromOrientationToOrientation(appView, ZephyrHomeInterfaceOrientation(), ZephyrOrientationFlip(ZephyrCurrentInterfaceOrientation()), YES);
    }

    shadowView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"SwitcherShadowTop.png"]];
    CGRect shadowFrame = [shadowView frame];
    shadowFrame.size.height = [[shadowView image] size].height;
    shadowFrame.size.width = [appView bounds].size.width;
    shadowFrame.origin.y = location - shadowFrame.size.height;
    [shadowView setFrame:shadowFrame];
    [shadowView setTransform:CGAffineTransformMakeScale(1, -1)];

    wrapperView = [[UIView alloc] initWithFrame:[appView bounds]];
    CGRect wrapperFrame = [wrapperView frame];
    wrapperFrame.origin.y = location;
    [wrapperView setFrame:wrapperFrame];
    [wrapperView setClipsToBounds:NO];
    [wrapperView addSubview:appView];

    centerView = [self listView];
    [centerView positionSlidingViewAtY:ZephyrHeightForOrientation(ZephyrCurrentInterfaceOrientation())];

    [centerView addSubview:wrapperView];
    [centerView addSubview:shadowView];
}

- (void)positionListViewAtY:(CGFloat)location {
    grabLocation = location;

    if (location < 0) location = 0;

    CGRect wrapperFrame = [wrapperView frame];
    wrapperFrame.origin.y = location;
    [wrapperView setFrame:wrapperFrame];

    CGRect shadowFrame = [shadowView frame];
    shadowFrame.origin.y = wrapperFrame.origin.y - shadowFrame.size.height;
    [shadowView setFrame:shadowFrame];
}

- (void)_handleUngrabWithVelocity:(CGPoint)velocity completion:(id)complete {
    %orig;
}

%end

%hook SBBulletinListView

// we fake the location in order to show the notification UI
// while we are sliding down, so re-fake back the current Y
- (CGFloat)currentY {
    if (!isnan(grabLocation)) {
        return grabLocation;
    } else {
        return %orig;
    }
}

%end

%hook SBUIController

static NotificationGesture *gesture = nil;

- (void)finishLaunching {
    %orig;

    return;

    int touches = [(NSNumber *) PreferencesGet(@"NotificationMinimumTouchCount", PreferencesGet(@"MinimumTouchCount", [NSNumber numberWithInt:1])) intValue];
    CGFloat edgeMargin = [(NSNumber *) PreferencesGet(@"NotificationSensitivityDistance", [NSNumber numberWithFloat:30.0f]) floatValue];

    gesture = [[NotificationGesture alloc] init];
    [gesture addOffscreenEdge:kSBOffscreenEdgeTop minimumTouchCount:touches edgeMargin:edgeMargin];

    PreferencesApplyActionRegister(^{
        int touches = [(NSNumber *) PreferencesGet(@"NotificationMinimumTouchCount", PreferencesGet(@"MinimumTouchCount", [NSNumber numberWithInt:1])) intValue];
        CGFloat edgeMargin = [(NSNumber *) PreferencesGet(@"NotificationSensitivityDistance", [NSNumber numberWithFloat:30.0f]) floatValue];

        for (SBOffscreenSwipeGestureRecognizer *recognizer in [gesture gestureRecognizers]) {
            [recognizer setMinTouches:touches];
            [recognizer setEdgeMargin:edgeMargin];
        }
    });
}

%end

%hook SBBulletinListView

- (void)positionSlidingViewAtY:(CGFloat)y {
    %orig;
}

%end

%end

%ctor {
    %init(Notification);
}

