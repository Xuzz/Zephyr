#import "Switcher.h"
#import "Preferences.h"
#import "Keyboard.h"
#import "NSTimer+Blocks.h"

#import "SwitchApp.h"
#import "LayerSnapshotter.h"

#include <dlfcn.h>

static BOOL disableUnscatterFlag = NO;

@interface SBMusicController : NSObject
- (void) switcherDidShow:(double)duration orientation:(UIInterfaceOrientation)orientation;
@end

static void OpenMusicControlsTaskSwitcherIfNecessaryWithDuration(double duration) {
    Class $SBMusicController = objc_getClass("SBMusicController");
    if ($SBMusicController) {
        bool defaultValue = YES;
        CFPreferencesSynchronize((CFStringRef)@"com.phoenix.musiccontrols.task", kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
        CFBooleanRef val = (CFBooleanRef) CFPreferencesCopyAppValue((CFStringRef) @"Controls", (CFStringRef) @"com.phoenix.musiccontrols.task");

        if (val) {
            defaultValue = [(NSNumber*) val boolValue];
            CFRelease(val);
        }

        if (defaultValue) {
            [[$SBMusicController sharedInstance] switcherDidShow:duration orientation:CurrentInterfaceOrientation()];
        }
    }
}

// based off of -[SBSwitchAppGestureView transofrmGestureViewContainer:]
static void TransformGestureViewContainer(UIView *container) {
    UIInterfaceOrientation currentOrientation = CurrentInterfaceOrientation();

    CGAffineTransform transform = CGAffineTransformIdentity;
    CGRect frame = CGRectZero;

    switch (currentOrientation) {
        case UIInterfaceOrientationPortrait:
            break;
        case UIInterfaceOrientationPortraitUpsideDown:
            transform = CGAffineTransformMakeRotation(M_PI);
            break;
        case UIInterfaceOrientationLandscapeLeft:
            transform = CGAffineTransformMakeRotation(M_PI / 2.0f);
            frame = [container frame];
            transform = CGAffineTransformTranslate(transform, (frame.size.width - frame.size.height) / 2.0f, (frame.size.width - frame.size.height) / 2.0f);
            break;
        case UIInterfaceOrientationLandscapeRight:
            transform = CGAffineTransformMakeRotation(M_PI / -2.0f);
            frame = [container frame];
            transform = CGAffineTransformTranslate(transform, (frame.size.width - frame.size.height) / -2.0f, (frame.size.width - frame.size.height) / -2.0f);
            break;
    }

    [container setTransform:transform];
}

static UIView *ViewWithScreenshotOfView(UIView *view) {
    dlopen("/usr/lib/liblayersnapshotter.dylib", RTLD_LAZY);
    if ([view respondsToSelector:@selector(renderSnapshot)]) {
        UIImage *viewImage = [view renderSnapshot];
        UIImageView *screenshotView = [[UIImageView alloc] initWithImage:viewImage];
        [screenshotView setFrame:[view frame]];
        return [screenshotView autorelease];
    } else {
        return [[[UIView alloc] initWithFrame:view.frame] autorelease];
    }
}

static void ActivateSwitcherFromToDuration(CGFloat from, CGFloat to, CGFloat duration) {
    SBUIController *uic = [objc_getClass("SBUIController") sharedInstance];

    SBShowcaseContext *zeroContext = [uic _showcaseContextForOffset:from];
    SBShowcaseContext *barContext = [uic _showcaseContextForOffset:to];

    [zeroContext setShowcaseOrientation:CurrentInterfaceOrientation()];
    [barContext setShowcaseOrientation:CurrentInterfaceOrientation()];

    SBAppSwitcherController *switcher = [objc_getClass("SBAppSwitcherController") sharedInstance];

    SBApplication *app = [SBApp _accessibilityFrontMostApplication];
    [switcher setupForApp:app orientation:CurrentInterfaceOrientation()];

    if (![objc_getClass("SBApplication") multitaskingIsSupported]) return;
    if ([switcher printViewIsShowing]) return;
    if ([uic isSwitcherShowing]) return;

    [uic _revealShowcase:switcher duration:duration from:zeroContext to:barContext];

    // Support Music Controls Pro, code by phoenixdev.
    OpenMusicControlsTaskSwitcherIfNecessaryWithDuration(duration);
}

static CGFloat HeightFromScreenPercentage(CGFloat percentage) {
    if (UIInterfaceOrientationIsLandscape(CurrentInterfaceOrientation())) {
        return [[UIScreen mainScreen] bounds].size.width * percentage;
    } else {
        return [[UIScreen mainScreen] bounds].size.height * percentage;
    }
}

@implementation SwitcherGesture

- (BOOL)shouldActivate {
    SBApplication *topApplication = [SBApp _accessibilityFrontMostApplication];
    if (topApplication == nil) topApplication = MSHookIvar<SBApplication *>([objc_getClass("SBUIController") sharedInstance], "_pendingAppActivatedByGesture");

    BOOL displayFlagsAllowed = YES;

    // Ensure topApplication is properly launched and ready.
    if (topApplication != nil) {
        if ([topApplication displayFlag:0x3]) displayFlagsAllowed = NO;
        if (![topApplication displayFlag:0x1]) displayFlagsAllowed = NO;
    }

    BOOL disableKeyboard = [(NSNumber *) PreferencesGet(@"BottomDisableKeyboard", PreferencesGet(@"DisableKeyboard", [NSNumber numberWithBool:YES])) boolValue];
    if (disableKeyboard) {
        if (KeyboardIsActive()) return NO;
    }

    NSString *topIdentifier = [topApplication displayIdentifier];
    BOOL disableIdentifier = [(NSNumber *) PreferencesGet([NSString stringWithFormat:@"BottomDisable-%@", topIdentifier], (id)kCFBooleanFalse) boolValue];
    if (disableIdentifier) return NO;

    SwipeUpAction action = (SwipeUpAction) [(NSNumber *) PreferencesGet(@"SwipeUpAction", [NSNumber numberWithInt:kSwipeUpActionCloseApp]) intValue];

    // This is needed to prevent re-activation before the animation completes, crashing.
    BOOL currentlyPendingSwitcherActivationsExist = (pendingSwitcherActivations != nil);
    BOOL switchAppGestureIsAnimating = SwitchAppGestureIsAnimatingCompletion();

    return ![SBApp _accessibilityIsSystemGestureActive]
        && ![[objc_getClass("SBAwayController") sharedAwayController] isLocked]
        && ![[objc_getClass("SBUIController") sharedInstance] isSwitcherShowing]
        && ![[objc_getClass("SBAssistantController") sharedInstance] isAssistantVisible]
        && ![[objc_getClass("SBBulletinWindowController") sharedInstance] isBusy]
        && ![[objc_getClass("SBBulletinListController") sharedInstanceIfExists] listViewIsActive]
        && ![[objc_getClass("SBIconController") sharedInstance] isEditing]
        && !currentlyPendingSwitcherActivationsExist
        && !switchAppGestureIsAnimating
        && [self currentOrientationIsSupported]
        && (topApplication == nil || displayFlagsAllowed)
        && (action == kSwipeUpActionSwitcher || action == kSwipeUpActionCloseApp);
}

- (SwipeUpAction)effectiveSwipeUpAction {
    SwipeUpAction action = (SwipeUpAction) [(NSNumber *) PreferencesGet(@"SwipeUpAction", [NSNumber numberWithInt:kSwipeUpActionCloseApp]) intValue];
    SBApplication *topApplication = [SBApp _accessibilityFrontMostApplication];

    if (action == kSwipeUpActionCloseApp && topApplication == nil) {
        action = kSwipeUpActionSwitcher;
    }

    return action;
}

- (void)cleanupViews {
    SBApplication *app = [SBApp _accessibilityFrontMostApplication];

    if (app != nil) {
        [app disableContextHostingForRequester:(CFStringRef) @"SwitchApp"];
    }

    [appView removeFromSuperview];
    appView = nil;

    [switcherView removeFromSuperview];
    switcherView = nil;

    [shadowView removeFromSuperview];
    shadowView = nil;

    [wrapperView release];
    [wrapperView removeFromSuperview];
    wrapperView = nil;

    for (NSArray *locationAndTimer in pendingSwitcherActivations) {
        NSTimer *timer = [locationAndTimer objectAtIndex:1];
        [timer invalidate];
    }

    [pendingSwitcherActivations release];
    pendingSwitcherActivations = nil;
}

- (void)handleGestureCanceled {
    // XXX: implement this correctly
}

- (void)handleGestureBeganWithLocation:(CGFloat)location {
    if ([[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad) {
        UIInterfaceOrientation currentOrientation = (UIInterfaceOrientation) [SBApp interfaceOrientationForCurrentDeviceOrientation];
        [[UIDevice currentDevice] setOrientation:currentOrientation animated:NO];
        [SBApp noteInterfaceOrientationChanged:currentOrientation];
    }

    pendingSwitcherActivations = [[NSMutableSet alloc] init];

    location = HeightFromScreenPercentage(location);
    SBApplication *app = [SBApp _accessibilityFrontMostApplication];

    // Ensure app is properly launched and ready.
    if (app != nil) {
        if ([app displayFlag:0x3]) return;
        if (![app displayFlag:0x1]) return;
    }

    if (app != nil) {
        [[[objc_getClass("SBUIController") sharedInstance] rootView] setAlpha:1.0f];

        UIView *gestureView = [[objc_getClass("SBGestureViewVendor") sharedInstance] viewForApp:app gestureType:kSBGestureTypeSwitchApp includeStatusBar:YES];

        CGRect gestureFrame = [gestureView frame];
        gestureFrame.origin = CGPointZero;

        if (UIInterfaceOrientationIsLandscape(CurrentInterfaceOrientation())) {
            gestureFrame.size.width = [gestureView frame].size.height;
            gestureFrame.size.height = [gestureView frame].size.width;
        }

        appView = [[UIView alloc] initWithFrame:gestureFrame];
        [appView addSubview:gestureView];
        [appView autorelease];

        TransformGestureViewContainer(gestureView);
    } else {
        // XXX: using contentView here isn't necessarily the best option, but it works.
        appView = ViewWithScreenshotOfView([[objc_getClass("SBUIController") sharedInstance] contentView]);

        // Call private UIKit API to cancel touches on the icon lists while swiping.
        // This fixes the bug where swiping up on an icon would start editing mode.
        if ([SBApp respondsToSelector:@selector(_cancelAllTouches)])
            [SBApp performSelector:@selector(_cancelAllTouches)];
    }

    shadowView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"SwitcherShadowTop.png"]];
    CGRect shadowFrame = [shadowView frame];
    shadowFrame.size = [[shadowView image] size];
    shadowFrame.size.width = [appView bounds].size.width;
    shadowFrame.origin.y = [appView bounds].size.height;
    [shadowView setFrame:shadowFrame];
    [shadowView autorelease];

    wrapperView = [[UIView alloc] initWithFrame:[appView bounds]];
    [wrapperView setClipsToBounds:NO];
    [wrapperView addSubview:appView];
    [wrapperView addSubview:shadowView];

    switcherView = [[objc_getClass("SBAppSwitcherController") sharedInstance] view];
    [[objc_getClass("SBAppSwitcherController") sharedInstance] setupForApp:app orientation:CurrentInterfaceOrientation()];

    CGFloat bottomBarHeight = [[objc_getClass("SBAppSwitcherController") sharedInstance] bottomBarHeight];
    CGRect switcherFrame = [switcherView frame];
    switcherFrame.origin.y = [appView bounds].size.height - bottomBarHeight;
    [switcherView setFrame:switcherFrame];

    if ([self effectiveSwipeUpAction] == kSwipeUpActionCloseApp) {
        [[objc_getClass("SBUIController") sharedInstance] restoreIconListAnimated:NO animateWallpaper:NO keepSwitcher:NO];
        [[objc_getClass("SBUIController") sharedInstance] notifyAppResignActive:app];
    }

    UIView *rootView = [[objc_getClass("SBUIController") sharedInstance] rootView];

    if ([self effectiveSwipeUpAction] == kSwipeUpActionSwitcher) {
        if (!linenView) {
            // TODO: Figure out why SBLinenView cannot give linens the full 320x480
            CGRect frame = rootView.bounds;
            frame.origin.y = switcherView.bounds.size.height - 320.0f;
            frame.size.height = 320.0f;
            linenView = [[%c(SBLinenView) alloc] initWithFrame:frame];
        }
        [switcherView insertSubview:linenView atIndex:0];
        MSHookIvar<UIView *>(switcherView, "_backgroundView").alpha = 0.0f;

        [rootView addSubview:switcherView];
    }

    [rootView addSubview:wrapperView];
    [rootView addSubview:shadowView];

    [UIView animateWithDuration:0.08f animations:^{
        CGFloat loc = HeightFromScreenPercentage(location);

        CGRect wrapperFrame = [wrapperView frame];
        wrapperFrame.origin.y = loc;
        [wrapperView setFrame:wrapperFrame];

        CGRect shadowFrame = [shadowView frame];
        shadowFrame.origin.y = wrapperFrame.size.height + loc;
        [shadowView setFrame:shadowFrame];
    }];
}

static CGFloat ScreenRounded(CGFloat value)
{
    CGFloat scale = [UIScreen mainScreen].scale;
    return roundf(value * scale) / scale;
}

- (void)handleGestureChangedWithLocation:(CGFloat)location velocity:(CGPoint)velocity {
    location = HeightFromScreenPercentage(location);

    CGFloat bottomBarHeight = [[objc_getClass("SBAppSwitcherController") sharedInstance] bottomBarHeight];

    // constrain to not going way off the screen
    if (location > 20.0f) location = 20.0f;

    if ([self effectiveSwipeUpAction] == kSwipeUpActionSwitcher) {
        // constrain to top of switcher
        if (location < -bottomBarHeight) {
            location = ScreenRounded((location + bottomBarHeight) * 0.2f - bottomBarHeight);
        }
    }

    CGRect wrapperFrame = [wrapperView frame];
    wrapperFrame.origin.y = location;
    [wrapperView setFrame:wrapperFrame];

    CGRect shadowFrame = [shadowView frame];
    shadowFrame.origin.y = wrapperFrame.size.height + location;
    [shadowView setFrame:shadowFrame];

    // Remove pending switcher activations outside range.
    NSMutableSet *pendingSwitcherActivationsToRemove = [NSMutableSet set];

    for (NSArray *locationAndTimer in pendingSwitcherActivations) {
        CGFloat originalLocation = [[locationAndTimer objectAtIndex:0] floatValue];
        NSTimer *timer = [locationAndTimer objectAtIndex:1];

        if (fabs(originalLocation - location) > 5.0f) {
            [timer invalidate];
            [pendingSwitcherActivationsToRemove addObject:locationAndTimer];
        }
    }

    for (NSArray *locationAndTimer in pendingSwitcherActivationsToRemove) {
        [pendingSwitcherActivations removeObject:locationAndTimer];
    }

    if ([self effectiveSwipeUpAction] == kSwipeUpActionCloseApp) {
        CGFloat delay = [PreferencesGet(@"BottomSwitcherActivationDelay", [NSNumber numberWithFloat:0.8f]) floatValue];

        if (delay > 0.0) {
            // No need to clear this from the timer list when done because the pendingSwitcherActiavtions is cleared when it fires.
            [pendingSwitcherActivations addObject:[NSArray arrayWithObjects:[NSNumber numberWithFloat:location], [NSTimer scheduledTimerWithTimeInterval:delay block:^(NSTimer *timer) {
                // prevent double activations
                if (![self isActive]) return;

                CGFloat bottomBarHeight = [[objc_getClass("SBAppSwitcherController") sharedInstance] bottomBarHeight];

                UIView *contentView = ViewWithScreenshotOfView([[objc_getClass("SBUIController") sharedInstance] contentView]);
                UIView *rootView = [[objc_getClass("SBUIController") sharedInstance] rootView];

                // XXX: this is a horrible hack
                UIImageView *switcherShadowView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"SwitcherShadowTop.png"]];
                CGRect shadowFrame = [switcherShadowView frame];
                shadowFrame.size = [[switcherShadowView image] size];
                shadowFrame.size.width = [contentView bounds].size.width;
                shadowFrame.origin.y = [contentView bounds].size.height;
                [switcherShadowView setFrame:shadowFrame];
                [switcherShadowView autorelease];

                CGRect switcherFrame = [switcherView frame];
                switcherFrame.origin.y = [appView bounds].size.height - bottomBarHeight;
                [switcherView setFrame:switcherFrame];

                [rootView addSubview:switcherView];
                [rootView addSubview:switcherShadowView];
                [rootView addSubview:contentView];
                [rootView addSubview:wrapperView];

                [UIView animateWithDuration:0.4f animations:^{
                    CGRect wrapperFrame = [wrapperView frame];
                    wrapperFrame.origin.y = -bottomBarHeight;
                    [wrapperView setFrame:wrapperFrame];

                    CGRect shadowFrame = [shadowView frame];
                    shadowFrame.origin.y = [wrapperView bounds].size.height + -bottomBarHeight;
                    [shadowView setFrame:shadowFrame];
                    [shadowView setAlpha:0.0f];

                    CGRect switcherShadowFrame = [switcherShadowView frame];
                    switcherShadowFrame.origin.y = [contentView bounds].size.height + -bottomBarHeight;
                    [switcherShadowView setFrame:switcherShadowFrame];

                    CGRect contentFrame = [contentView frame];
                    contentFrame.origin.y = -bottomBarHeight;
                    [contentView setFrame:contentFrame];
                } completion:^(BOOL finished) {
                    [self cleanupViews];

                    [contentView removeFromSuperview];
                    [switcherShadowView removeFromSuperview];

                    ActivateSwitcherFromToDuration(bottomBarHeight, bottomBarHeight, 0.0f);
                }];

                [self cancelGesture];
            } repeats:NO], nil]];
        }
    }
}

- (void)handleGestureEndedWithLocation:(CGFloat)location velocity:(CGPoint)velocity completionType:(int)type {
    location = HeightFromScreenPercentage(location);

    SBApplication *app = [SBApp _accessibilityFrontMostApplication];

    if ([self effectiveSwipeUpAction] == kSwipeUpActionSwitcher) {
        // XXX: maybe use the completionType here
        CGFloat bottomBarHeight = [[objc_getClass("SBAppSwitcherController") sharedInstance] bottomBarHeight];
        if (-location >= bottomBarHeight * (2.0f / 3.0f)) {
            CGFloat from, to, duration;
            if (location < -bottomBarHeight)
                location = ScreenRounded((location + bottomBarHeight) * 0.2f - bottomBarHeight);
            from = -location;
            to = bottomBarHeight;
            duration = 0.3f;

            dispatch_async(dispatch_get_main_queue(), ^{
                [linenView.superview sendSubviewToBack:linenView];
                [UIView animateWithDuration:duration animations:^{
                    MSHookIvar<UIView *>(switcherView, "_backgroundView").alpha = 1.0f;
                } completion:^(BOOL completed) {
                    [linenView removeFromSuperview];
                    [linenView release];
                    linenView = nil;
                }];
                [self cleanupViews];
                ActivateSwitcherFromToDuration(from, to, duration);
            });
        } else {
            [UIView animateWithDuration:0.3f animations:^{
                CGRect wrapperFrame = [wrapperView frame];
                wrapperFrame.origin = CGPointZero;
                [wrapperView setFrame:wrapperFrame];

                CGRect shadowFrame = [shadowView frame];
                shadowFrame.origin.y = wrapperFrame.size.height;
                [shadowView setFrame:shadowFrame];
            } completion:^(BOOL completed) {
                [self cleanupViews];
                [linenView removeFromSuperview];
                [linenView release];
                linenView = nil;
            }];
        }
    } else {
        if (type == 1) {
            [SBApp showSpringBoardStatusBar];

            UIViewAnimationOptions options = (UIViewAnimationOptionCurveEaseOut | UIViewAnimationOptionBeginFromCurrentState);
            [UIView animateWithDuration:0.3f delay:0.0f options:options animations:^{
                CGRect wrapperFrame = [wrapperView frame];
                wrapperFrame.origin.y = -wrapperFrame.size.height;
                [wrapperView setFrame:wrapperFrame];

                CGRect shadowFrame = [shadowView frame];
                shadowFrame.origin = CGPointZero;
                [shadowView setFrame:shadowFrame];
            } completion:^(BOOL completed) {
                [self cleanupViews];

                // Stolen from SwitchApp.xmi; this is a bad decompliation of
                // what a different function does than the one I am reversing.
                [app setDeactivationSetting:24 flag:YES];
                [app setDeactivationSetting:18 flag:YES];

                // XXX: the "disableIconUnscatter" display flag there does not work, so:
                disableUnscatterFlag = YES;

                /* sub_2C330 */ {
                    if ([SBWActiveDisplayStack containsDisplay:app] || [SBWSuspendedEventOnlyDisplayStack containsDisplay:app]) {

                        /* sub_2B9B8 */ {
                            // this is a crude approximation of sorta kinda what this gigantic
                            // function does, since I'm waaaaay too lazy to reverse the whole
                            // thing: even just the graph in IDA is quite scary to look at! :(
                            [SBWActiveDisplayStack popDisplay:app];
                            [SBWSuspendingDisplayStack pushDisplay:app];
                        }
                    } else if (![SBWSuspendingDisplayStack containsDisplay:app]) {
                        [app clearDeactivationSettings];
                    }
                }
            }];
        } else {
            [UIView animateWithDuration:0.3f animations:^{
                CGRect wrapperFrame = [wrapperView frame];
                wrapperFrame.origin = CGPointZero;
                [wrapperView setFrame:wrapperFrame];

                CGRect shadowFrame = [shadowView frame];
                shadowFrame.origin.y = wrapperFrame.size.height;
                [shadowView setFrame:shadowFrame];
            } completion:^(BOOL completed) {
                [self cleanupViews];

                [[objc_getClass("SBUIController") sharedInstance] notifyAppResumeActive:app];
                [[objc_getClass("SBUIController") sharedInstance] stopRestoringIconList];
                [[objc_getClass("SBUIController") sharedInstance] tearDownIconListAndBar];
            }];
        }
    }
}

@end

%group Switcher

%hook SBUIController

static SwitcherGesture *gesture = nil;

- (void)finishLaunching {
    %orig;

    int touches = [(NSNumber *) PreferencesGet(@"BottomMinimumTouchCount", PreferencesGet(@"MinimumTouchCount", [NSNumber numberWithInt:1])) intValue];
    CGFloat edgeMargin = [(NSNumber *) PreferencesGet(@"BottomSensitivityDistance", [NSNumber numberWithFloat:30.0f]) floatValue];

    gesture = [[SwitcherGesture alloc] init];
    [gesture addOffscreenEdge:kSBOffscreenEdgeBottom minimumTouchCount:touches edgeMargin:edgeMargin];

    PreferencesApplyActionRegister(^{
        int touches = [(NSNumber *) PreferencesGet(@"BottomMinimumTouchCount", PreferencesGet(@"MinimumTouchCount", [NSNumber numberWithInt:1])) intValue];
        CGFloat edgeMargin = [(NSNumber *) PreferencesGet(@"BottomSensitivityDistance", [NSNumber numberWithFloat:30.0f]) floatValue];

        for (SBOffscreenSwipeGestureRecognizer *recognizer in [gesture gestureRecognizers]) {
            [recognizer setMinTouches:touches];
            [recognizer setEdgeMargin:edgeMargin];
        }
    });
}

- (void)restoreIconListAnimated:(BOOL)animated animateWallpaper:(BOOL)wallpaper keepSwitcher:(BOOL)switcher {
    if (disableUnscatterFlag) {
        disableUnscatterFlag = NO;
        animated = NO;
    }

    %orig(animated, wallpaper, switcher);
}

%end

%end

%ctor {
    %init(Switcher);
}

