
#import "SwitchApp.h"
#import "Common.h"
#import "Preferences.h"
#import "Keyboard.h"

static BOOL isAnimatingCompletion = NO;

BOOL SwitchAppGestureIsAnimatingCompletion() {
    return isAnimatingCompletion;
}

@implementation SwitchAppGesture

- (BOOL)shouldActivateAtEdge:(SBOffscreenEdge)edge {
    BOOL disableKeyboard = [(NSNumber *) PreferencesGet(@"SideDisableKeyboard", PreferencesGet(@"DisableKeyboard", [NSNumber numberWithBool:YES])) boolValue];
    if (disableKeyboard) {
        if (KeyboardIsActive()) return NO;
    }

    SBApplication *topApplication = [SBApp _accessibilityFrontMostApplication];

    if (topApplication != nil) {
        BOOL disableIdentifier = [(NSNumber *) PreferencesGet([NSString stringWithFormat:@"SideDisable-%@", [topApplication displayIdentifier]], (NSNumber *) kCFBooleanFalse) boolValue];
        if (disableIdentifier) return NO;
    }

    // Put this after the above check so you can quickly page through disabled apps.
    if (topApplication == nil) topApplication = MSHookIvar<SBApplication *>([objc_getClass("SBUIController") sharedInstance], "_pendingAppActivatedByGesture");

    return topApplication != nil
        && [self currentOrientationIsSupported]
        && ![SBApp _accessibilityIsSystemGestureActive]
        && ![[objc_getClass("SBUIController") sharedInstance] isSwitcherShowing]
        && ![[objc_getClass("SBBulletinWindowController") sharedInstance] isBusy]
        && !ZephyrAssistantIsVisible()
        && ![[objc_getClass("SBBulletinListController") sharedInstanceIfExists] listViewIsActive]
        && [(NSNumber *) PreferencesGet(@"SwipeSideEnabled", [NSNumber numberWithBool:YES]) boolValue];
}

- (BOOL)shouldUseGrabberAtEdge:(SBOffscreenEdge)edge {
    return [(NSNumber *) PreferencesGet(@"SideGrabberEnabled", NO) boolValue];
}

- (BOOL)currentOrientationIsSupported {
    return YES;
}

- (void)handleGestureCanceled {
    SBUIController *uic = [objc_getClass("SBUIController") sharedInstance];
    [uic _switchAppGestureCancelled];
}

- (void)handleGestureBeganWithLocation:(CGFloat)location {
    SBUIController *uic = [objc_getClass("SBUIController") sharedInstance];

    if ([uic respondsToSelector:@selector(_switchAppGestureBegan)])
        [uic _switchAppGestureBegan];
    else if ([uic respondsToSelector:@selector(_switchAppGestureBegan:)])
        [uic _switchAppGestureBegan:location];
}

- (void)handleGestureChangedWithLocation:(CGFloat)location velocity:(CGPoint)velocity {
    SBUIController *uic = [objc_getClass("SBUIController") sharedInstance];
    [uic _switchAppGestureChanged:location];
}

- (void)handleGestureEndedWithLocation:(CGFloat)location velocity:(CGPoint)velocity completionType:(int)type {
    SBUIController *uic = [objc_getClass("SBUIController") sharedInstance];
    [uic _switchAppGestureEndedWithCompletionType:type cumulativePercentage:location];
}

@end

@interface SBUIController (Zephyr)
- (void)_switchAppGestureBeganInternal;
@end

%group SwitchApp

%hook SBUIController

static UIView *containerView = nil;

// This is dumb as fuck. The "has multitasking gestures" state is stored in
// a random global variable which we cannot hook, and is set in a C function
// without an (exposed) name, so we also cannot hook that. This C function is
// called from dozens of methods, and as such cannot be hooked, especially as
// many of those functions that call it /break/ if you apply the necessary
// hooks around them (as well as the C function setting the varaible). Ugh. :(

- (void)_switchAppGestureBegan {
    [self _switchAppGestureBeganInternal];
}

- (void)_switchAppGestureBegan:(CGFloat)location {
    [self _switchAppGestureBeganInternal];
}

%new(v@:)
- (void)_switchAppGestureBeganInternal {
    // Attempt to emulate the C function call here.
    if ([SBApp _accessibilityIsSystemGestureActive]) return;

    SBApplication *topApplication = [SBApp _accessibilityFrontMostApplication];

    if (topApplication != nil) {
        if ([topApplication displayFlag:0x3]) return;
        if (![topApplication displayFlag:0x1]) return;
    }

    // (there is some condition here in a C function, dunno what it does)
    if (![self _dismissSheetsAndDetermineAlertStateForMenuClickOrSystemGesture]) return;

    // If there is no top app, try the currently launching app from this gesture.
    // This allows you to quickly swipe through apps, even as they load or resume.
    if (topApplication == nil) {
        topApplication = MSHookIvar<SBApplication *>(self, "_pendingAppActivatedByGesture");
        if (topApplication == nil) return;
    }

    NSMutableArray *unfilteredList = MSHookIvar<NSMutableArray *>(self, "_switchAppFullyOrderedList");
    if (unfilteredList == nil) {
        [self _calculateSwitchAppList];
        unfilteredList = MSHookIvar<NSMutableArray *>(self, "_switchAppFullyOrderedList");
    }

    NSArray *filteredList = [self _makeSwitchAppFilteredList:unfilteredList initialApp:topApplication];
    int topApplicationIndex = [filteredList indexOfObject:[topApplication displayIdentifier]];

    if ([filteredList count] == 0 || topApplicationIndex == NSNotFound) return;

    // FIXME: iOS 6 preloads something here, figure out what it does

    SBBulletinListController *bulletinListController = [objc_getClass("SBBulletinListController") sharedInstanceIfExists];
    if ([bulletinListController listViewIsActive]) {
        [bulletinListController hideListViewAnimated:YES];
    }

    MSHookIvar<BOOL>(self, "_switcherVisibleWhenSwitchAppGestureStarted") = [self isSwitcherShowing];

    [self clearPendingAppActivatedByGesture];
    [self _lockOrientationForSystemGesture];
    [self cleanupSwitchAppGestureViews];

    if (topApplication != nil) {
        if (![topApplication displayFlag:0x22]) {
            if ([topApplication respondsToSelector:@selector(suspensionType)] && [topApplication respondsToSelector:@selector(process)]) {
                if (![topApplication displayFlag:0x1]) {
                    if ([topApplication suspensionType] == 0) {
                        // call some C functions, that sorta do this (i'm too lazy to reverse these:)
                        [topApplication setDeactivationSetting:0xC flag:YES];
                        [[topApplication process] killWithSignal:9];
                    }
                }
            }
        } else {
            [self notifyAppResignActive:topApplication];
        }
    }

    UIInterfaceOrientation currentOrientation = ZephyrCurrentInterfaceOrientation();
    if ([[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad) {
        // some c function... and another one.. sorta the second one below
        [[UIDevice currentDevice] setOrientation:currentOrientation animated:NO];
        [SBApp noteInterfaceOrientationChanged:currentOrientation];
    }

    [self showSystemGestureBackdrop];

    SBApplicationController *applicationController = [objc_getClass("SBApplicationController") sharedInstance];
    SBApplication *leftApplication = [applicationController applicationWithDisplayIdentifier:[filteredList objectAtIndex:0]];
    SBApplication *rightApplication = [applicationController applicationWithDisplayIdentifier:[filteredList lastObject]];

    if (leftApplication == topApplication) leftApplication = nil;
    if (rightApplication == topApplication) rightApplication = nil;

    [containerView removeFromSuperview];
    [MSHookIvar<SBSwitchAppGestureView *>(self, "_switchAppGestureView") removeFromSuperview];
    [MSHookIvar<SBSwitchAppGestureView *>(self, "_switchAppGestureView") release];

    MSHookIvar<SBSwitchAppGestureView *>(self, "_switchAppGestureView") = [[objc_getClass("SBSwitchAppGestureView") alloc] initWithInterfaceOrientation:currentOrientation startingApp:topApplication leftwardApp:leftApplication rightwardApp:rightApplication];
    [MSHookIvar<SBSwitchAppGestureView *>(self, "_switchAppGestureView") setContentScaleFactor:[[UIScreen mainScreen] scale]];

    containerView = [[UIView alloc] initWithFrame:[MSHookIvar<UIView *>(self, "_contentView") bounds]];
    [containerView addSubview:MSHookIvar<SBSwitchAppGestureView *>(self, "_switchAppGestureView")];
    [MSHookIvar<UIView *>(self, "_contentView") addSubview:containerView];
    ZephyrRotateViewFromOrientationToOrientation(containerView, ZephyrHomeInterfaceOrientation(), ZephyrCurrentInterfaceOrientation(), YES);
    [containerView release];

    [MSHookIvar<SBSwitchAppGestureView *>(self, "_switchAppGestureView") beginPaging];

    [self prepareSwitchAppGestureStatusBar];
    if ([self respondsToSelector:@selector(setRootViewHiddenForScatter:duration:startTime:)]) {
        [self setRootViewHiddenForScatter:0 duration:0.0 startTime:0.0];
    } else if ([self respondsToSelector:@selector(setRootViewHiddenForScatter:duration:delay:)]) {
        [self setRootViewHiddenForScatter:0 duration:0.0 delay:0.0];
    }
    [self updateSwitchAppGestureStatusBar];


    if ([self isSwitcherShowing]) {
        [self _dismissShowcase:0.0f unhost:NO];
    }
}

- (void)_switchAppGestureChanged:(CGFloat)percentage {
    [MSHookIvar<SBSwitchAppGestureView *>(self, "_switchAppGestureView") updatePaging:percentage];
    [self updateSwitchAppGestureStatusBar];
}

- (void)_switchAppGestureEndedWithCompletionType:(int)type cumulativePercentage:(float)percentage {
    SBSwitchAppGestureView *gestureView = MSHookIvar<SBSwitchAppGestureView *>(self, "_switchAppGestureView");

    void (^completion)() = ^{
        isAnimatingCompletion = NO; // chpwn addition

        [self _switchAppGestureViewAnimationComplete];
    };

    if (gestureView != nil) {
        if (type == 1) {
            isAnimatingCompletion = YES; // chpwn addition

            [gestureView finishForwardToEndWithPercentage:percentage completion:completion];
        } else if (type == -1) {
            isAnimatingCompletion = YES; // chpwn addition

            [gestureView finishBackwardToStartWithCompletion:completion];
        }
    }

    [self updateSwitchAppGestureStatusBar];
}

- (void)_switchAppGestureCancelled {
    SBSwitchAppGestureView *gestureView = MSHookIvar<SBSwitchAppGestureView *>(self, "_switchAppGestureView");

    [self _switchAppGestureEndedWithCompletionType:-1 cumulativePercentage:0.0f];

    if (gestureView != nil) {
        [self _switchAppGestureViewAnimationComplete];
        [self cleanupSwitchAppGestureViews];
    }
}

- (void)_switchAppGestureViewAnimationComplete {
    SBSwitchAppGestureView *gestureView = MSHookIvar<SBSwitchAppGestureView *>(self, "_switchAppGestureView");
    if (gestureView == nil) return;

    [self hideSystemGestureBackdrop];

    SBApplication *startingApplication = [gestureView startingApp];
    SBApplication *endingApplication = [gestureView endingApp];

    [containerView removeFromSuperview];
    containerView = nil;
    [gestureView removeFromSuperview];
    [gestureView release];
    MSHookIvar<SBSwitchAppGestureView *>(self, "_switchAppGestureView") = nil;

    BOOL endingAppHasLaunchedFrontmost = [endingApplication displayFlag:1];

    if ([self respondsToSelector:@selector(clearZoomLayer)]) {
        [self clearZoomLayer];
    }

    if (startingApplication != endingApplication) {
        //UIInterfaceOrientation statusOrientation = [startingApplication statusBarOrientation];
        [startingApplication setDeactivationSetting:0x18 flag:YES];

        /* sub_2C330 */ {
            if ([SBWActiveDisplayStack containsDisplay:startingApplication] || [SBWSuspendedEventOnlyDisplayStack containsDisplay:startingApplication]) {
                /* sub_2B9B8 */ {
                    // this is a crude approximation of sorta kinda what this gigantic
                    // function does, since I'm waaaaay too lazy to reverse the whole
                    // thing: even just the graph in IDA is quite scary to look at! :(
                    [SBWActiveDisplayStack popDisplay:startingApplication];
                    [SBWSuspendingDisplayStack pushDisplay:startingApplication];
                }
            } else if (![SBWSuspendingDisplayStack containsDisplay:startingApplication]) {
                [startingApplication clearDeactivationSettings];
            }
        }
    }

    SBApplicationController *applicationController = [objc_getClass("SBApplicationController") sharedInstance];
    for (NSString *displayIdentifier in MSHookIvar<NSArray *>(self, "_switchAppFilteredList")) {
        SBApplication *application = [applicationController applicationWithDisplayIdentifier:displayIdentifier];

        if (application != endingApplication) {
            [application disableContextHostingForRequester:CFSTR("SwitchApp")];
        }
    }

    [self cleanupSwitchAppGestureViews];

    BOOL shouldShowSwitcherAgain = NO;

    if (!endingAppHasLaunchedFrontmost) {
        // ending app hasn't launched; launch it now
        [self showSystemGestureBackdrop];
        [self scheduleApplicationForLaunchByGesture:endingApplication];
        [self _installSwitchAppGesturePlaceholderViewForEndingApp:endingApplication];

        if (startingApplication == endingApplication) {
            shouldShowSwitcherAgain = YES;
        }
    } else {
        [endingApplication disableContextHostingForRequester:CFSTR("SwitchApp")];
        [endingApplication disableContextHostingForRequester:CFSTR("LaunchSuspend")];

        if (startingApplication == endingApplication) {
            // ending app is same as starting app, resume it
            [self notifyAppResumeActive:endingApplication];

            shouldShowSwitcherAgain = YES;
        } else {
            // ending app needs to be re-launched, do it
            [self showSystemGestureBackdrop];
            [self scheduleApplicationForLaunchByGesture:endingApplication];
            [self _installSwitchAppGesturePlaceholderViewForEndingApp:endingApplication];
        }
    }

    if (shouldShowSwitcherAgain && MSHookIvar<BOOL>(self, "_switcherVisibleWhenSwitchAppGestureStarted")) {
        // show switcher again if it was hidden for the gesture to start

        if ([self respondsToSelector:@selector(_activateSwitcherFrom:to:duration:)]) {
            SBAppSwitcherController *appSwitcherController = [objc_getClass("SBAppSwitcherController") sharedInstance];

            SBShowcaseContext *zeroContext = [self _showcaseContextForOffset:0];
            SBShowcaseContext *barContext = [self _showcaseContextForOffset:[appSwitcherController bottomBarHeight]];

            UIInterfaceOrientation currentOrientation = [SBApp activeInterfaceOrientation]; // also someting about "CAMediaTime", huh
            [zeroContext setShowcaseOrientation:currentOrientation];
            [barContext setShowcaseOrientation:currentOrientation];

            [self _activateSwitcherFrom:zeroContext to:barContext duration:0];
        } else if ([self respondsToSelector:@selector(_activateSwitcher:fromSystemGesture:)]) {
            [self _activateSwitcher:0.0 fromSystemGesture:YES];
        }
    }

    MSHookIvar<BOOL>(self, "_switcherVisibleWhenSwitchAppGestureStarted") = NO;
    MSHookIvar<BOOL>(self, "_switchAppGestureStatusBarMaintained") = NO;

    // two more C functions; unknown purpose

    [self _resumeEventsIfNecessary];

    if (endingAppHasLaunchedFrontmost) {
        [self _releaseSystemGestureOrientationLock];
    }
}

static SwitchAppGesture *gesture = nil;

- (void)finishLaunching {
    %orig;

    int touches = [(NSNumber *) PreferencesGet(@"SideMinimumTouchCount", PreferencesGet(@"MinimumTouchCount", [NSNumber numberWithInt:1])) intValue];
    CGFloat edgeMargin = [(NSNumber *) PreferencesGet(@"SideSensitivityDistance", [NSNumber numberWithFloat:30.0f]) floatValue];

    gesture = [[SwitchAppGesture alloc] init];
    [gesture addOffscreenEdge:kSBOffscreenEdgeRight minimumTouchCount:touches edgeMargin:edgeMargin];
    [gesture addOffscreenEdge:kSBOffscreenEdgeLeft minimumTouchCount:touches edgeMargin:edgeMargin];

    PreferencesApplyActionRegister(^{
        int touches = [(NSNumber *) PreferencesGet(@"SideMinimumTouchCount", PreferencesGet(@"MinimumTouchCount", [NSNumber numberWithInt:1])) intValue];
        CGFloat edgeMargin = [(NSNumber *) PreferencesGet(@"SideSensitivityDistance", [NSNumber numberWithFloat:30.0f]) floatValue];

        for (SBOffscreenSwipeGestureRecognizer *recognizer in [gesture gestureRecognizers]) {
            [recognizer setMinTouches:touches];
            [recognizer setEdgeMargin:edgeMargin];
        }
    });
}

// avoid conflict between native gesture and custom gesture on the iPad
- (void)handleFluidHorizontalSystemGesture:(SBGestureRecognizer *)recognizer {
    if ([gesture isActive] || SwitchAppGestureIsAnimatingCompletion()) return;

    %orig;
}

%end

%end

%ctor {
    %init(SwitchApp);
}

